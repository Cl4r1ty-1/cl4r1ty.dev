---
layout: writeup
title: Exfiltrated Entropy
tags: crypto forensics
---

We are given a zip file to download which includes 4 files. 3 python files and a pcap files

![alt text](https://github.com/Cl4r1ty-1/CTF/blob/main/HTB%20University/images/exfilen.png?raw=true)


Upon opening the pcap file using Wireshark, we see that there are not many packets or devices. All of the traffic in this file is 2 devices communicating to each other using some sort of TCP protocol 

![alt text](https://github.com/Cl4r1ty-1/CTF/blob/main/HTB%20University/images/wireshark1.png?raw=true)

Looking closer into the capture we see packets that are sending data in a JSON format such as 

`{"init": true, "id": "efbb599758d1743333e5b43ac3e4e2b2", "cmd": "2ulbTirRTzn+EKa1bvu3"}`

We then decide to look into the Python files. There are 3 Python scripts: `server.py`, `client.py`, and `params.py`. `params.py` seems to just hold variables that both the scripts import:

![alt text](https://github.com/Cl4r1ty-1/CTF/blob/main/HTB%20University/images/params1.png?raw=true)

Both the `client.py` and `server.py` files include a class named `LCG` which uses `params.py` and a `secret.py` file that we don't have access to that seems to include a `SEED` value. This `SEED` value, along with the values in `params.py` are used to encrypt and decrypt the communications between the server and the client.
{% highlight python %}
...
from params import *
from secret import SEED
from base64 import b64encode as be, b64decode as bd
...

class LCG:
    def __init__(self):
        self.state = SEED
        self.a = a        # a, b, m from params.py file
        self.b = b
        self.m = m
    
    def _next(self):
        self.state = (self.a * self.state + self.b) % self.m
        return self.state
    
    def generate_key(self, l):
        return bytes([self._next() & 0xff for _ in range(l)])

    def generate_packet_uuid(self):
        return hex(self._next())

    def encrypt(self, msg):
        key = self.generate_key(len(msg))
        return xor(msg, key)
    
    def decrypt(self, msg):
        return self.encrypt(msg)
{% endhighlight %}

Looking further into the server and client files we see they are used to send shell commands between each other, the client connects to the server and the server is able to run commands on the client, with all communication being encrypted in between.

We know know that we need to find a way to decrypt whatever is in those packet captures.
Since the encryption just uses XOR, we need a way to find the XOR key. Luckily the way the key is generated is right there in the `LCG` class. The `generate_key` function takes the value generated by the `_next` function (which we'll look at closer later), ensures that only a byte of that is kept and puts that value in a list, it does that for the length of the plaintext command until it has a key the same size as the command (as this is required for secure XOR encryption). The `_next` function takes the values from `params.py` (the `a`, `b` and `m` values) and `secret.py` (the `SEED` value) and does some math and modular arithmetic to generate a `state`. This is the function we need to reverse to get the `SEED` value. The formula the `_next` function uses is:

$$
(a \cdot \text{state} + b) \mod m
$$

We can reverse this function by getting the `id` value in the JSON we saw in the packet capture, each packet sent to the client has its own unique ID that corresponds to the state value at the time of encryption (as seen here in the below function)

{% highlight python %}
def generate_packet_uuid(self): 
	return hex(self._next())
{% endhighlight %}

By taking that value and converting it from hex to decimal, we can use this formula to reverse the `_next` function.

$$
((a^{-1} \mod m) \cdot (\mathrm{id} - b)) \mod m
$$



Which takes the inverse mod of `a` mod `m`, multiplies it with `b` from `params.py` subtracted from the `id` value from the packet, all modulo `m` from `params.py`. We can write this in Python as follows:
{% highlight python %}
# current_state is the id value from hex
# prev_state is the seed for that packet
def reverse_state(current_state, a, b, m):
    a_inverse = pow(a, -1, m)  # Modular inverse of a mod m
    prev_state = (a_inverse * (current_state - b)) % m
    return prev_state
{% endhighlight %}

Now that we have reversed the encryption key generation process, we can find the seed and begin decrypting packets. The full script I used for this is below:

{% highlight python %}
from params import *
from base64 import b64encode as be, b64decode as bd
import json
from Crypto.Util.number import long_to_bytes, bytes_to_long
from math import gcd
from pwn import *

def reverse_state(current_state, a, b, m):
    a_inverse = pow(a, -1, m)  # Modular inverse of a mod m
    prev_state = (a_inverse * (current_state - b)) % m
    return prev_state

class LCG:
    def __init__(self, a, b, m):
        self.a = a
        self.b = b
        self.m = m
    
    def set_state(self, state):
        self.state = state

    def _next(self):
        self.state = (self.a * self.state + self.b) % self.m
        return self.state

    def generate_key(self, l):
        return bytes([self._next() & 0xff for _ in range(l)])

    def encrypt(self, msg):
        key = self.generate_key(len(msg))
        return xor(msg, key)

    def decrypt(self, msg):
        return self.encrypt(msg)


id_hex = "8829affbed23334d34016095627ba065" # id parameter from json in packet
enc_cmd_b64 = "4FfTtXHCD3LuRRJzLIzwyeylqqGwyTiugfjOo+MbNhyKv1ZDgSL33Lwaysu+dlONfwJ8jaqbuTVnVqwFloEI4wGdC9FFkmJgLpV9y3AZyjM0wsV+DRVR1cpOBvQqT4F46j2JiDxvABDqHRw5yrmv+uByJMyX/cZM2azJMonAVwV95ncUg0uWs3bmpturCW9sWiVaQ2pqjgAuUDs3Yab1/jJa4tthhkJrBJl6cyX88ijWqoMBKUkjsZ/sNa8uGLpC9gGpafUQwfyaPfImxIx8taB8bain59NlaI2RaL3YFfRrkxQAw8rUshLbxqI/AhpOH9LRQ09GeORcBnHPC0HaqMFDgp0euCJzrnVhdDmPrPPGhq/MsfISmr3R94HfOE4hs/h4ceMywp+qHOLZ/1RlvVoSBrK5w7o4G16PJLC9Xf8UzC6rQO5PQBiOcpNgCPg7NvToEickQd7CTBWQOEy+Rv0ar8gnTAooy2cjMe2iqeuEMTOd5Pz8QKS721vcxU4AU4cLDbwhr4tKteb3v3oGcAEiPF9sSoMbBlhoE0m7+f8wLPHvXrgfShSKBD0L9vccz42AMCUZGu+Ctw2QASe5apAnvWz0c+u3rD3aG8aXZo+hF3K4u7rjRkulqm2B+mD9aeJiVb2zlah74L6iRW0MUR7PvXkXSnnaX2sW8E9Y3obSBo2gEqcQAqhLAlsu7Y3y9Jyc87LJEMSf/tmq/BBEFIjcXXWBBO3ys1rK3vFdb5pfND6ApIO/AEhRoguD/SDGCpkOqkjXYk8cgSWaTE3aMULyhCZwFlHsyVMS9CodoFvAbInIEjE+L8ptHDff6IbbkENz/83i7SOGitFn3epsL0fyQjWlA5CSdceb/opVJVUeVwdYbVO4DC9XTRtDivq3VkbI0WL3cHUqmXcmAKzcGMSV/xkMB2Th6vAq+xcYhhm8EoFxqXC14e00/0XlvXm0pkZngfmo0Gd0qqJYofA34HS/Miuy6deJd5u3mnMeUGsv6O9mZ3VlpAUTQtEJXJvbzXbB7j+VPhb3J2JRRs+a9N2Is8jyyRO3tI7kmskDPRyMx1pg4jH138wWyqOvfWXVcTE+qNa+gh4VUZkDsaNE9H2+E/dyx2tKH78htEtT0zkU5tIOCzFl19odAJUdGapWjjqZmEBYKzGIdRF53KLK9qdmPczHycB8uYqRdNbLZixO2lIshAmGh1yx8ZKVGD1/RgFdPiE9k1YxHGQXd5Lmvg=="  # Encrypted command from packet
id_value = bytes_to_long(bytes.fromhex(id_hex))


lcg = LCG(a, b, m)

current_state = id_value
for _ in range(1000):
    current_state = reverse_state(current_state, a, b, m)
    lcg.set_state(current_state)
    
    enc_cmd = bd(enc_cmd_b64)
    try:
        decrypted_cmd = lcg.decrypt(enc_cmd)
        print(f"Potential SEED: {current_state}")
        print(f"Decrypted Command: {decrypted_cmd}")
        
        if decrypted_cmd.isascii():
            print("Found plausible SEED!")
            break
    except Exception as e:
        continue
{% endhighlight %}

After decrypting a few packets, we found one that contained the flag:

```
Encrypted Command: 4FfTtXHCD3LuRRJzLIzwyeylqqGwyTiugfjOo+MbNhyKv1ZDgSL33Lwaysu+dlONfwJ8jaqbuTVnVqwFloEI4wGdC9FFkmJgLpV9y3AZyjM0wsV+DRVR1cpOBvQqT4F46j2JiDxvABDqHRw5yrmv+uByJMyX/cZM2azJMonAVwV95ncUg0uWs3bmpturCW9sWiVaQ2pqjgAuUDs3Yab1/jJa4tthhkJrBJl6cyX88ijWqoMBKUkjsZ/sNa8uGLpC9gGpafUQwfyaPfImxIx8taB8bain59NlaI2RaL3YFfRrkxQAw8rUshLbxqI/AhpOH9LRQ09GeORcBnHPC0HaqMFDgp0euCJzrnVhdDmPrPPGhq/MsfISmr3R94HfOE4hs/h4ceMywp+qHOLZ/1RlvVoSBrK5w7o4G16PJLC9Xf8UzC6rQO5PQBiOcpNgCPg7NvToEickQd7CTBWQOEy+Rv0ar8gnTAooy2cjMe2iqeuEMTOd5Pz8QKS721vcxU4AU4cLDbwhr4tKteb3v3oGcAEiPF9sSoMbBlhoE0m7+f8wLPHvXrgfShSKBD0L9vccz42AMCUZGu+Ctw2QASe5apAnvWz0c+u3rD3aG8aXZo+hF3K4u7rjRkulqm2B+mD9aeJiVb2zlah74L6iRW0MUR7PvXkXSnnaX2sW8E9Y3obSBo2gEqcQAqhLAlsu7Y3y9Jyc87LJEMSf/tmq/BBEFIjcXXWBBO3ys1rK3vFdb5pfND6ApIO/AEhRoguD/SDGCpkOqkjXYk8cgSWaTE3aMULyhCZwFlHsyVMS9CodoFvAbInIEjE+L8ptHDff6IbbkENz/83i7SOGitFn3epsL0fyQjWlA5CSdceb/opVJVUeVwdYbVO4DC9XTRtDivq3VkbI0WL3cHUqmXcmAKzcGMSV/xkMB2Th6vAq+xcYhhm8EoFxqXC14e00/0XlvXm0pkZngfmo0Gd0qqJYofA34HS/Miuy6deJd5u3mnMeUGsv6O9mZ3VlpAUTQtEJXJvbzXbB7j+VPhb3J2JRRs+a9N2Is8jyyRO3tI7kmskDPRyMx1pg4jH138wWyqOvfWXVcTE+qNa+gh4VUZkDsaNE9H2+E/dyx2tKH78htEtT0zkU5tIOCzFl19odAJUdGapWjjqZmEBYKzGIdRF53KLK9qdmPczHycB8uYqRdNbLZixO2lIshAmGh1yx8ZKVGD1/RgFdPiE9k1YxHGQXd5Lmvg==

Decrypted command:
echo "H4sIAAE4/WYAA+1YOXLDMAzs9Ro+My0bPzAvyYwnlsjF7gKkncJJOGoIgMDipKT2efsYn9YaUmAfn4LEfcG2EVsgNvOiRrMogvW1okCaPD5v/f6MQZ4pj00HxkxRLNR+QukjuiB10roA1Ikzyvcl8UxNz0WNyaPFeMyuIaldMVCnHkH9tg2pVmWPUl3uRsd0FzGqaTmtckUXFbf7dSeqRJdpZzNGOz2J3T/w5p6ZepJVZinvor1ZRM2IuFDw9GOXe53y2FP7smsbDF0belpmtcFPAoVlcKRre9WpQK6LZCOVMXX3mn6BlfIu2QQ8U1QNHFEBaaIpgeCPCXftvhO0V2adqHXNt2VLmNvKPcdzVUQ587ELkVIgxYeManV30WmAhMW95EVBYn4FWUmZtmKdkqPSv1U8jUox8lif7/BnHbZIKZDiM9/+nRxoVDUSFveSl1qqIiooyQT3YrzjTpFYiOXR/sL69/L3rNFLMpL5soKK6S6znL275rvPqhW26zCGWD5GQiGURlAxwy3Yg2RBZHexKZmHFO0DJTN6yL8EPdJpujEshVeMAIz5OhOmu0YweIAM6he5Eo7V/l1FfZD/QVs5oUe8R2c1YIwAoeV0yeEGxUlRz5kVredbCABFyotcWThKHLcmzK+3lRlCOzbkNyZbuy3RSkS7WSWuD4I4cfQQ4smw37GlI9nPi7yfzk8P2g0xl7LEfjSbLK8xgQyVazxXxnQkiQCi0oJ7DHzF/UzldLFEr2hOaS0T45HBz4nuyPj+1c/wEjhlXBsYdAy2gxPk2RiSAZSqRy1zy1feZ+duuB7NUH8MzAHk+Z8JhmcglLBs2Fb+LgaByDJaRaWaC7D1eX+nBb1XLW5Yb+Uz5Hrb6ffyWjTV2voCIBKnivUiAAA=" | base64 -d | gunzip
```

After running this command in our own Linux terminal we get:

![alt text](https://github.com/Cl4r1ty-1/CTF/blob/main/HTB%20University/images/flag1.png?raw=true)

Flag:
`HTB{still_not_convinced_about_LCG_security?}`
